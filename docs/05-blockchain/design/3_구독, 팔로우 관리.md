## 1. 컨트랙트 개요

**FollowRegistry**는 GreatDIY에서  
“누가 어떤 전략(strategyId)을 실제로 사용(follow) 중인지”를 온체인에서 증명하는 레이어다.

이 컨트랙트는 다음을 보장한다.

1. `(user, strategyId)` 단위로 **팔로우 상태(State) 관리**
2. SettlementManager가 **정산 생성 대상 사용자**를 식별할 수 있는 기준 제공
    - Active 상태 + sinceDay / lastSettledDay 조합
3. Settlement가 만료(Expired)된 사용자의 팔로우를 **자동 Paused 상태로 전환할 수 있는 훅 제공**
4. Follow 상태 변화를 이벤트로 남겨 오프체인 인덱싱/조회에 활용

---

## 2. 역할(Role) 연동

FollowRegistry는 AccessControl/Config의 역할(Role)을 사용한다.

|역할|기능|
|---|---|
|**ADMIN**|강제 Pause/Stop 등 비상 조치, 정책 변경|
|**BACKEND_RELAYER**|특정 상황에 대한 운영상 강제 Pause (옵션)|
|**SETTLEMENT_OPERATOR**|정산 처리 후 `lastSettledDay` 업데이트, Expired 시 강제 Pause|
|**VERIFIER**|사용 X|
|**TREASURY**|사용 X|

→ 원칙

- **팔로우/일시정지/종료**: user 본인이 호출
- **정산 관련 업데이트**: SETTLEMENT_OPERATOR
- **위험 전략/불량 유저에 대한 강제 조치**: ADMIN (필요 시 BACKEND_RELAYER)

---

## 3. 팔로우 데이터 구조

### 3-1. Follow 상태값

팔로우는 다음 상태를 가진다:

- `None` : 팔로우 기록 없음 (기본값)
- `Active` : 전략을 사용 중이며, 해당 기간에 대해 정산 대상
- `Paused` : 일시 중지. 자동매매 비활성, 이 기간은 정산 대상 아님
- `Stopped` : 완전 종료. 이후 다시 사용하려면 새롭게 follow 호출 필요

> SettlementManager는 **`status == Active`인 `(user, strategyId)`에 대해서만**  
> 해당 일(dayIndex)의 정산 후보로 고려한다.

---

### 3-2. 온체인에 저장되는 Follow 구조체

`struct Follow {     uint8   status;         // None / Active / Paused / Stopped     uint64  sinceDay;       // UTC+0 기준 dayIndex. 이 날부터 요금 부과 시작     uint64  lastSettledDay; // 가장 최근에 정산이 완료된 dayIndex }`

설명:

- `sinceDay`
    - 최초 Active가 된 dayIndex
    - SettlementManager는 `(lastSettledDay + 1) ~ (currentDay - 1)` 사이를 “미정산 기간” 후보로 볼 수 있다.
- `lastSettledDay`
    - SETTLEMENT_OPERATOR가 정산 성공 후 업데이트
    - dayIndex는 Config의 `dayIndexDefinition`과 동일한 기준

### 상태 변수

`mapping(address => mapping(uint256 => Follow)) public follows;   mapping(address => uint256[]) public userStrategies;   uint256 public totalFollows;`

- `follows[user][strategyId]`  
    → 해당 유저의 해당 전략 팔로우 상태
- `userStrategies[user]`  
    → 해당 유저가 지금까지 팔로우를 시도했던 strategyId 목록 (오프체인 인덱싱용)
- `totalFollows`  
    → 전체 Follow 레코드 수 (통계/인덱싱 용도)

> 목록 조회/검색/정렬은 온체인이 아니라 **오프체인(PostgreSQL 등)** 에서  
> 이벤트 기반 인덱싱으로 처리한다.

---

## 4. 핵심 기능(Function) 명세

### 4-1. 팔로우 생성 (Follow 시작)

**호출 권한: user 본인 (`msg.sender`)**

`follow(uint256 strategyId, uint64 currentDayIndex)`

#### 조건

- StrategyRegistry:
    - `status == Active`
    - `isListed[strategyId] == true`
- FollowRegistry:
    - `follows[msg.sender][strategyId].status` 가
        - `None` 이거나
        - `Stopped` 인 경우에만 새로운 팔로우 허용  
            (Stopped → 다시 시작은 “새 구독”으로 간주)
- Staking/Quota:
    - G8DStaking + Config를 통해 현재 등급(Tier)의 **최대 팔로우 수**를 넘지 않는지 체크 (구현은 별도 컨트랙트)

#### 효과

- `follows[user][strategyId]` 갱신:
    - `status = Active`
    - `sinceDay = currentDayIndex`
    - `lastSettledDay = currentDayIndex - 1` (이전까지는 정산 대상 아님)
- `userStrategies[user]`에 `strategyId`가 처음 팔로우되는 경우 추가
- `totalFollows++`
- `FollowStarted(user, strategyId, currentDayIndex)` 이벤트 발생

---

### 4-2. 팔로우 일시정지 (Pause)

**호출 권한: user 본인**

`pauseFollow(uint256 strategyId)`

#### 조건

- `follows[user][strategyId].status == Active`

#### 효과

- `status: Active → Paused`
- `sinceDay`, `lastSettledDay`는 변경 없음
- `FollowPaused(user, strategyId)` 이벤트

> 이 시점부터는 새로운 dayIndex에 대해 정산 대상에서 제외된다  
> (SettlementManager 측에서 status == Active 조건으로 필터링)

---

### 4-3. 팔로우 재개 (Resume)

**호출 권한: user 본인**

`resumeFollow(uint256 strategyId, uint64 currentDayIndex)`

#### 조건

- `follows[user][strategyId].status == Paused`
- StrategyRegistry
    - `status == Active`
    - `isListed[strategyId] == true`
- Staking/Quota:
    - 재개 시점의 팔로우 쿼타도 충족해야 함

#### 효과

- `status: Paused → Active`
- `sinceDay`를 **재개 시점 기준**으로 다시 설정할지, 원래 sinceDay 유지할지는 정책 선택:
    - 정산 로직을 단순하게 하기 위해:
        - **권장**: `sinceDay = currentDayIndex`, `lastSettledDay = currentDayIndex - 1` 로 리셋  
            → “재개 이후 기간만 다시 과금”
- `FollowResumed(user, strategyId, currentDayIndex)` 이벤트

---

### 4-4. 팔로우 종료 (Stop)

**호출 권한: user 본인**

`stopFollow(uint256 strategyId)`

#### 조건

- `status == Active` 또는 `status == Paused`

#### 효과

- `status: Active/Paused → Stopped`
- `sinceDay`, `lastSettledDay`는 기록 보존용으로 남겨둘 수 있음
- 이후 다시 사용하려면 `follow(...)`를 새로 호출해야 한다.
- `FollowStopped(user, strategyId)` 이벤트

---

### 4-5. 정산 후 lastSettledDay 업데이트

**호출 권한: SETTLEMENT_OPERATOR (SettlementManager)**

`markSettled(address user, uint256 strategyId, uint64 dayIndex)`

#### 조건

- `follows[user][strategyId].status` 가 `Active` 또는 `Paused` 또는 `Stopped` 중 하나
- `dayIndex > follows[user][strategyId].lastSettledDay`  
    (과거 일자에 대한 중복 업데이트 방지)

#### 효과

- `lastSettledDay = dayIndex`
- `FollowSettled(user, strategyId, dayIndex)` 이벤트

> SettlementManager는 이 함수를 통해 어떤 일자까지 정산이 완료되었는지  
> FollowRegistry에 기록해 둔다.  
> Expired 판단 및 자동 Pause 로직의 기준이 된다.

---

### 4-6. 정산 만료(Expired)에 따른 자동 Pause

**호출 권한: SETTLEMENT_OPERATOR 또는 ADMIN**

`pauseDueToExpiredSettlement(     address user,     uint256 strategyId,     uint64 expiredDayIndex )`

#### 시나리오

- 특정 dayIndex에 대한 Settlement가 생성되었으나  
    사용자가 정산 기한(예: 3일)을 넘겨 결제를 하지 않아 **Expired** 상태가 되었을 때,
- 해당 전략을 더 이상 사용하지 못하도록 팔로우를 강제 Pause한다.

#### 조건

- `follows[user][strategyId].status == Active`
- `follows[user][strategyId].lastSettledDay < expiredDayIndex`  
    (미정산 기간이 존재한다는 의미)

#### 효과

- `status: Active → Paused`
- `FollowPausedBySystem(user, strategyId, expiredDayIndex)` 이벤트

> 이 함수는 SettlementManager에서 “Expired Settlements를 처리하는 루프” 안에서  
> `(user, strategyId)` 단위로 호출된다.

---

### 4-7. 관리자 강제 조치 (Admin Controls)

**호출 권한: ADMIN**

`adminPauseFollow(address user, uint256 strategyId) adminStopFollow(address user, uint256 strategyId)`

- 정책 위반, 악용, 법적 이슈 등으로 특정 유저의 팔로우를 강제 중단할 때 사용
- SettlementManager와 상관없이 직접 상태를 조정 가능
- 각각 `AdminFollowPaused`, `AdminFollowStopped` 이벤트 발생

---

### 4-8. 조회용 함수

**view 함수들 (가스 없이 eth_call로 사용)**

`function getFollow(address user, uint256 strategyId)     external     view     returns (Follow memory);  function isActiveFollower(address user, uint256 strategyId)     external     view     returns (bool);  function getUserStrategies(address user)     external     view     returns (uint256[] memory);`

- `isActiveFollower`는 SettlementManager나 백엔드에서 간편 체크용
- `getUserStrategies`는 오프체인 인덱싱/대시보드에 활용

---

## 5. 이벤트(Event) 명세

|이벤트|설명|
|---|---|
|`FollowStarted(user, strategyId, sinceDay)`|새로운 팔로우 생성 (Active 진입)|
|`FollowPaused(user, strategyId)`|유저가 직접 일시정지|
|`FollowResumed(user, strategyId, sinceDay)`|유저가 직접 재개|
|`FollowStopped(user, strategyId)`|유저가 팔로우 완전 종료|
|`FollowSettled(user, strategyId, dayIndex)`|해당 일자에 대한 정산 완료 기록|
|`FollowPausedBySystem(user, strategyId, expiredDayIndex)`|정산 만료로 시스템에 의해 강제 Pause|
|`AdminFollowPaused(user, strategyId)`|ADMIN에 의한 강제 Pause|
|`AdminFollowStopped(user, strategyId)`|ADMIN에 의한 강제 Stop|

→ 모든 이벤트는 오프체인(PostgreSQL 등)에서 팔로우 이력/정산 이력을 재구성하는 데 사용된다.

---

## 6. 컨트랙트 간 연동

### StrategyRegistry

- `follow` / `resumeFollow` 호출 시:
    - `status == Active`인지 확인
    - `isListed[strategyId] == true`인지 확인
- 전략이 Suspended된 경우:
    - SettlementManager 또는 BACKEND_RELAYER가  
        개별 `(user, strategyId)`에 대해 `adminPauseFollow`를 호출하거나  
        오프체인 엔진에서 해당 전략에 대한 자동매매를 중단

### SettlementManager

- 정산 대상 선정 시:
    - `status == Active`인 팔로우만 고려
    - `sinceDay`, `lastSettledDay`를 참조해 미정산 기간 계산
- 정산 완료 후:
    - `markSettled(user, strategyId, dayIndex)` 호출
- 정산 만료 시:
    - `pauseDueToExpiredSettlement(user, strategyId, dayIndex)` 호출

### FeeDistributor

- FollowRegistry는 직접 참조하지 않지만,
- FeeDistributor가 전략 기준으로 수익 분배할 때,  
    “해당 전략을 사용하는 유저 수” 등은 오프체인 인덱싱에서 계산 가능

### DecisionHistory

- DecisionHistory는 `(user, strategyId, dayIndex)` 기준으로  
    어떤 결정/주문들이 있었는지 기록
- SettlementManager는 DecisionHistory + FollowRegistry 조합으로  
    “이 날 실제로 사용 중이었던 팔로우”에 대한 정산 데이터를 생성한다.

---

## 7. 보안 및 설계상의 주의사항

- **루프/대량 처리 금지**
    - FollowRegistry 내부에서 모든 유저를 순회하는 로직 없음
    - SettlementManager가 `(user, strategyId)` 단위로 필요한 만큼만 호출
- **역할 분리**
    - 유저: 자신의 팔로우 라이프사이클 관리
    - SETTLEMENT_OPERATOR: 정산 데이터와 lastSettledDay 관리
    - ADMIN: 비상/규제/악용 대응용 강제 조치
- **재진입 공격 (reentrancy)**
    - 단순 상태 변경 + 이벤트만 수행하므로 구조상 재진입 리스크 낮음
- **데이터 일관성**
    - `lastSettledDay`는 반드시 단조 증가하도록 체크
    - Expired 처리 시 dayIndex 기준 검증 필수

---

## 8. Constructor & 초기 세팅

`constructor(address configAddress) {     config = IConfig(configAddress);     totalFollows = 0; }`

- AccessControl/Config 주소를 받아 역할(Role) 조회에 사용
- 별도 초기 파라미터 없음
---

## 9. 요약

- FollowRegistry는 `(user, strategyId)` 단위의 **팔로우 상태 + 정산 기준 일자**를 온체인에 기록한다.
- SettlementManager는 이 정보를 기반으로:
    - Active 상태의 사용자만 정산 대상으로 삼고
    - Expired 발생 시 자동 Pause를 트리거한다.
- 목록/검색/정렬/통계는 오프체인 DB(PostgreSQL 등)에서  
    이벤트를 인덱싱하여 처리하고, 온체인은 “사실의 증명” 역할에 집중한다.